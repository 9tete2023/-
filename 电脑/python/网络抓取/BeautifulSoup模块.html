<!DOCTYPE html>
<html lang="zh">
<head>
<title>BeautifulSoup模块</title>
<!-- 2015-11-15 21:23 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="万泽(德山书生)">
<meta  name="description" content="制作者邮箱：a358003542@gmail.com"
>
<style type="text/css"> /*
 * with_bootstrap.css
 *
 * Copyright 2015 wanze <a358003542@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 *
 *
 */

@import url("http://getbootstrap.com/dist/css/bootstrap.min.css");

/* Sticky footer styles
-------------------------------------------------- */
html {
    position: relative;
    min-height: 100%;
    margin: 0px;
}
body {
    /* Margin bottom by footer height */
    margin-bottom: 60px;
}
footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    /* Set the fixed height of the footer here */
    height: 60px;
    background-color: #f5f5f5;
}

/* Custom page CSS
-------------------------------------------------- */
/* Not required for template or sticky footer method. */

.container {
  width: auto;
  max-width: 750px;
  padding: 0 15px;
}
.container .text-muted {
  margin: 20px 0;
}

/* background-color: #f8f8f8; */
.navbar-default{
    background-color: #fff;
}
/*--------------------*/

#content{
    margin: 0 auto;
    max-width: 750px;
    padding: 17px;
    line-height:160%;
    font-size:16px;
}

h1,h2,h3,h4,h5,h6 {
    font-family: 'PT Sans Narrow', sans-serif;
    font-weight: 700;
    margin-bottom: 1em;
    margin-top: 1em;
}


pre{line-height:180%;font-size:90%;}
code,kbd,pre,samp {
  font-family: monospace, serif;
}

code{  padding: 2px;}
p{
    text-indent:2em;/*段落缩进*/
    line-height:180%;/*行间距*/
    }

.title{
    text-align: center;
}
.org-ol li , .org-ul li , org-dl dt{
    margin-top: 0.5em; /*增大li之间的垂直space*/
    margin-bottom: 0.5em; /*增大li之间的垂直space*/
}
p.verse{
    margin-left: 3%;
    text-indent:0em;
}

.right{
    margin-left: auto;
    margin-right: 0px;
    text-align: right;
}
.left{
    margin-left: 0px;
    margin-right: auto;
    text-align: left;
}
.center{
    margin-left: auto;
    margin-right: auto;
    text-align: center;
}

.underline{
    text-decoration: underline;
}


video{
    width: 750px;
    margin-left: auto;
    margin-right: auto;
}

figure p{
    text-indent:0em;/*段落缩进*/
}
img{
    max-width: 700px;
}

figure{
    text-align: center;
}

table, th, td
{
    margin:0 auto;
    min-width:2em;
    text-align:center ;
    padding: 5px;
}

table{
    border-top: 2px solid ;
    border-bottom: 2px solid ;
}
thead{
    border-bottom: 1px solid ;
}

/*  class  */
.framed{
    max-width:700px;
    border:1px solid ;
    padding: 1em;
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}

.notecard{
    width: 320px;
    position:relative;
    right: -215px;
    padding: 1em;
    margin:0 auto;
    border: solid 1px;
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}

/*
http://thomasf.github.io/solarized-css/
*/

dfn {
  font-style: italic;
}
dd{
    margin-left:2em;
}
mark {
  background: #ff0;
  color: #000;
}

q {
  quotes: "\201C" "\201D" "\2018" "\2019";
}
small {
  font-size: 80%;
}
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sup {
  top: -0.5em;
}
sub {
  bottom: -0.25em;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
}



.tag {
  background-color: #eee8d5;
  color: #d33682;
  padding: 0 0.2em;
}


.todo,
.next,
.done {
  color: #fdf6e3;
  background-color: #dc322f;
  padding: 0 0.2em;
}
.tag {
  -webkit-border-radius: 0.35em;
  -moz-border-radius: 0.35em;
  border-radius: 0.35em;
}
.TODO {
  -webkit-border-radius: 0.2em;
  -moz-border-radius: 0.2em;
  border-radius: 0.2em;
  background-color: #2aa198;
}
.NEXT {
  -webkit-border-radius: 0.2em;
  -moz-border-radius: 0.2em;
  border-radius: 0.2em;
  background-color: #268bd2;
}
.ACTIVE {
  -webkit-border-radius: 0.2em;
  -moz-border-radius: 0.2em;
  border-radius: 0.2em;
  background-color: #268bd2;
}
.DONE {
  -webkit-border-radius: 0.2em;
  -moz-border-radius: 0.2em;
  border-radius: 0.2em;
  background-color: #859900;
}
.WAITING {
  -webkit-border-radius: 0.2em;
  -moz-border-radius: 0.2em;
  border-radius: 0.2em;
  background-color: #cb4b16;
}
.HOLD {
  -webkit-border-radius: 0.2em;
  -moz-border-radius: 0.2em;
  border-radius: 0.2em;
  background-color: #d33682;
}
.NOTE {
  -webkit-border-radius: 0.2em;
  -moz-border-radius: 0.2em;
  border-radius: 0.2em;
  background-color: #d33682;
}
.CANCELLED {
  -webkit-border-radius: 0.2em;
  -moz-border-radius: 0.2em;
  border-radius: 0.2em;
  background-color: #859900;
}


/*
pygmentize -f html -S colorful -a .highlight
*/

.highlight .hll { background-color: #ffffcc }
.highlight  { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */

 </style>
</head>
<body>
<header class="header">
<nav class="navbar navbar-default navbar-static-top"><div class="container">
<div class="navbar-header">
<a class="navbar-brand" href="http://www.cdwanze.org"><img style="max-width:50px; margin-top: -15px;" src="/templates/images/logo.svg" /></a></div>
<div id="navbar">
<ul class="nav navbar-nav"><li class="active"><a href="http://blog.cdwanze.org">博客</a><li><a href="http://blog.cdwanze.org/about.html">关于</a><li><a href="http://blog.cdwanze.org/donate.html">支持</a></div>
</div>
</nav></header><div id="content">
<h1 class="title">BeautifulSoup模块</h1>
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 简介</a>
<ul>
<li><a href="#sec-1-1">1.1. 安装</a></li>
<li><a href="#sec-1-2">1.2. 第一个例子</a></li>
</ul>
</li>
<li><a href="#sec-2">2. find方法</a>
<ul>
<li><a href="#sec-2-1">2.1. 过滤器</a></li>
<li><a href="#sec-2-2">2.2. class_参量</a></li>
<li><a href="#sec-2-3">2.3. id参量</a></li>
<li><a href="#sec-2-4">2.4. text参量</a></li>
<li><a href="#sec-2-5">2.5. 其他keywords</a></li>
<li><a href="#sec-2-6">2.6. recursive参量</a></li>
<li><a href="#sec-2-7">2.7. limit参量</a></li>
</ul>
</li>
<li><a href="#sec-3">3. find_all方法</a></li>
<li><a href="#sec-4">4. 标签元素对象</a></li>
<li><a href="#sec-5">5. 基于某个标签的附加查找</a>
<ul>
<li><a href="#sec-5-1">5.1. 平行级别上下标签</a>
<ul>
<li><a href="#sec-5-1-1">5.1.1. 平行级别下标签</a></li>
<li><a href="#sec-5-1-2">5.1.2. 平行级别上标签</a></li>
</ul>
</li>
<li><a href="#sec-5-2">5.2. 非平行级别上下标签</a></li>
</ul>
</li>
<li><a href="#sec-6">6. select方法</a></li>
<li><a href="#sec-7">7. 解析部分文档来提升效率</a></li>
</ul>
</div>
</nav>



<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 简介</h2>
<div class="outline-text-2" id="text-1">
<p>
BeautifulSoup模块在python网页分析这一块是很有名的一个模块，其确实让网页分析任务变得轻松而easy了。本文将对bs4模块进行简单的介绍，更多细节请参看 <a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/">官方文档</a> 。
</p>
</div>


<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 安装</h3>
<div class="outline-text-3" id="text-1-1">
<p>
安装就简单用pip命令安装之:
</p>

<pre class="example">
sudo pip install beautifulsoup
</pre>
</div>
</div>


<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 第一个例子</h3>
<div class="outline-text-3" id="text-1-2">
<p>
然后在使用上因为python2和python3的urllib相关改动很大，加上urllib在使用上不是很友好，强烈推荐大家直接用requests模块来进行相关操作。然后beautifulsoup的引入语句一般如下所示:
</p>

<pre class="example">
from bs4 import BeautifulSoup
</pre>


<p>
最简单的和requests的组合使用如下所示:
</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;http://www.pythonscraping.com/exercises/exercise1.html&quot;</span><span class="p">)</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="p">)</span>
</pre></div>

<p>
在上面soup.title返回的是一个标签对象。然后标签对象里面如果有标签的话又可以继续点号索引标签:
</p>
<pre class="example">
&gt;&gt;&gt; soup.body.h1
&lt;h1&gt;An Interesting Title&lt;/h1&gt;
</pre>

<p>
这时读者一定在想，文档里面相同的p标签有很多，soup会返回什么呢？
</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;http://www.crummy.com/software/BeautifulSoup/bs4/doc/&quot;</span><span class="p">)</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
</pre></div>

<p>
我们看到soup返回的是第一个p标签，这可以看作下面要讲的find方法的简化css索引形式。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> find方法</h2>
<div class="outline-text-2" id="text-2">
<p>
如下所示最简单的find定位实际上就类似于 <code>soup.p</code> 的用法。但find方法里面有更丰富的内容。
</p>
<pre class="example">
&gt;&gt;&gt; soup.find('p')
&lt;p&gt;&lt;a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/"&gt;Beautiful Soup&lt;/a&gt; is a
Python library for pulling data out of HTML and XML files. It works
with your favorite parser to provide idiomatic ways of navigating,
searching, and modifying the parse tree. It commonly saves programmers
hours or days of work.&lt;/p&gt;
</pre>

<p>
find方法如果找不到就返回None，找到则返回目标标签元素。
</p>
<pre class="example">
&gt;&gt;&gt; soup.test is None
True
</pre>
</div>


<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 过滤器</h3>
<div class="outline-text-3" id="text-2-1">
<p>
find方法最常用的形式是接受一个参数，这个参数叫做什么过滤器参数。过滤器可以是字符串或正则表达式或列表组成，其中列表里面的元素基于前面谈及的字符串或正则表达式，然后组成或逻辑，只要符合一个匹配条件就认为是匹配的。
</p>

<p>
第一个参量也就是name参量是针对tag的操作，通常简单的字符串就够用了，如果是正则表达式的话，则是 <code>re.compile("^b")</code> 这样的形式，然后其内是通过正则表达式的 <strong>match</strong> 方法来完成的（稍作测试，我觉得应该对应的re.search。）。
</p>

<p>
最后要额外一提的就是过滤器 <code>True</code> ，其会匹配任何值，比如说 <code>id=True</code> ，将会匹配所有有id属性的标签。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> class_参量</h3>
<div class="outline-text-3" id="text-2-2">
<p>
你可以通过 <code>class_=</code> 来过滤标签的class属性，注意为了和python的class关键词区分，后面加上了一个下划线，同样是接受一个过滤器。
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> id参量</h3>
<div class="outline-text-3" id="text-2-3">
<p>
你可以通过 <code>id=</code> 来具体定位网页中的某个id，也是接受一个过滤器。
</p>
</div>
</div>


<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> text参量</h3>
<div class="outline-text-3" id="text-2-4">
<p>
对网页各个标签内的字符串进行过滤操作，前面提及的过滤器一样都可以用，不过字符串是精确匹配的我估计用得会比较少。尽可能地用正则表达式。然后如果单独使用text参量
</p>
<pre class="example">
soup.find_all(text=re.compile('name'))
</pre>
<p>
标签里面的字符串也会被搜索，而且返回也不一定是标准的标签元素对象，这很不好。推荐采用如下形式:
</p>
<pre class="example">
soup.find_all(True,text=re.compile('name'))
</pre>
<p>
这样返回的必定是标签元素，而且text里面必定只搜索标签的text字符串内容，这更易于人们的理解。
</p>

<p>
然后搜索完之后你可能定位到的是某个小标签，比如 <code>&lt;b&gt;</code> 之类的，然后你可以对目标标签元素使用 <code>.parent</code> ，则将返回更高一级的标签元素，这有时会很有用的:
</p>
<pre class="example">
soup.find_all(True,text=re.compile('name'))[-1].parent
</pre>
</div>
</div>


<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> 其他keywords</h3>
<div class="outline-text-3" id="text-2-5">
<p>
其他标签的各个属性都可以类似上面的作为关键词加上过滤器来搜索。比如
</p>
<pre class="example">
oup.find_all(href=re.compile("elsie"))
</pre>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> recursive参量</h3>
<div class="outline-text-3" id="text-2-6">
<p>
recursive默认是True，也就是检索当前tag的所有子孙节点，如果只想搜索当前tag的第一级子节点，则使用 <code>recursive=False</code> 。 
</p>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> limit参量</h3>
<div class="outline-text-3" id="text-2-7">
<p>
这个只对find_all才有意义，确定返回几个元素。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> find_all方法</h2>
<div class="outline-text-2" id="text-3">
<p>
find_all和find方法API类似，除了find_all返回的是一系列匹配的标签元素的列表。在这里顺便提一下，find方法和find_all方法可以接受多个参数作为限定，这些限定条件可以看作逻辑与关系。
</p>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 标签元素对象</h2>
<div class="outline-text-2" id="text-4">
<p>
具体标签元素的使用见下面例子:
</p>
<pre class="example">
&gt;&gt;&gt; import re
&gt;&gt;&gt; soup.find(True,text=re.compile("sister"))
&lt;span class="s"&gt;&amp;lt;p class="story"&amp;gt;Once upon a time there were three little sisters; and their names were&lt;/span&gt;
&gt;&gt;&gt; thetag = soup.find(True,text=re.compile("sister"))
&gt;&gt;&gt; thetag.name
'span'
&gt;&gt;&gt; thetag.text
'&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were'
&gt;&gt;&gt; thetag.string
'&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were'
&gt;&gt;&gt; type(thetag.string)
&lt;class 'bs4.element.NavigableString'&gt;
&gt;&gt;&gt; type(thetag.text)
&lt;class 'str'&gt;
&gt;&gt;&gt; thetag['class']
['s']
</pre>
<dl class="org-dl">
<dt> name </dt><dd>标签对象的标签名字
</dd>
<dt> string </dt><dd>返回NavigableString对象，这里暂时先略过讨论。
</dd>
<dt> text </dt><dd>返回标签所包含的文本对象。
</dd>
<dt> get_text() </dt><dd>从最新的bs4文档来看，官方文档推荐tag获取其内文本内容都用 <code>get_text</code> 方法，而不要使用上面的 <code>thetag.text</code> 这种形式了。
</dd>
<dt> ['class'] </dt><dd>属性值索引，上面的"class"属性具体返回的是一个列表，叫做什么多值属性。
</dd>
</dl>
</div>
</div>



<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 基于某个标签的附加查找</h2>
<div class="outline-text-2" id="text-5">
<p>
我们通过 <code>find</code> 或 <code>find_all</code> 能够找到某个或某些标签对象了，然后bs4还给标签对象加上了一些辅助查找方法，基于这个标签对象来进一步查找，从而返回其他某个或某些标签对象。
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 平行级别上下标签</h3>
<div class="outline-text-3" id="text-5-1">
<p>
这里所谓的平行级别上下标签是指如下面这个例子:
</p>
<pre class="example">
&lt;html&gt;
    &lt;body&gt;
        &lt;a&gt;
            &lt;b&gt;text1&lt;/b&gt;
            &lt;c&gt;text2&lt;/c&gt;
        &lt;/a&gt;
        &lt;d&gt;test3&lt;/d&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
&lt;b&gt;标签和&lt;c&gt;标签就是一个html文档缩进深度，它们就属于一个层次的平行标签。而&lt;a&gt;和&lt;d&gt;也是属于平行标签，但&lt;b&gt;和&lt;d&gt;则不是。
</p>
</div>

<div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1"><span class="section-number-4">5.1.1</span> 平行级别下标签</h4>
<div class="outline-text-4" id="text-5-1-1">
<pre class="example">
find_next_sibling(name, attrs, string, **kwargs)
</pre>

<p>
才外还有返回一些标签对象（对应find_all方法）的方法:
</p>
<pre class="example">
find_next_siblings(name, attrs, string, limit, **kwargs)
</pre>

<p>
比如上面的例子我们有:
</p>
<pre class="example">
&gt;&gt;&gt; [ i for i in soup.a.next_siblings]
['\n', &lt;d&gt;test3&lt;/d&gt;, '\n']
&gt;&gt;&gt; [ i for i in soup.b.next_siblings]
['\n', &lt;c&gt;text2&lt;/c&gt;, '\n']
&gt;&gt;&gt;
</pre>

<p>
这些方法的用法和前面谈及的 <code>find</code> 还有 <code>find_all</code> 类似，但多少有点令人沮丧的是，beautifulsoup受到换行符的干扰，在 <a href="https://stackoverflow.com/questions/23241641/how-to-ignore-empty-lines-while-using-next-sibling-in-beautifulsoup4-in-python">这篇网页</a> 中提到预处理网页将换行符都换成空格，然后将标签之间的各个空格符号都删除的解决方案，虽然不是很完美，但作为解决也是可以接受的，因为网络抓取实际上进来的网页简化预处理是必须要做的一步工作。
</p>
</div>
</div>


<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2"><span class="section-number-4">5.1.2</span> 平行级别上标签</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
平行级别上标签类似上面的描述，不过是往上走，这里就不赘述了。
</p>
<pre class="example">
find_previous_sibling(name, attrs, string, **kwargs)
</pre>


<p>
此外还有返回一些标签对象（对应find_all方法）的方法:
</p>
<pre class="example">
find_previous_siblings(name, attrs, string, limit, **kwargs)
</pre>
</div>
</div>
</div>



<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 非平行级别上下标签</h3>
<div class="outline-text-3" id="text-5-2">
<p>
find_parents(name, attrs, string, limit, **kwargs)
find_parent(name, attrs, string, **kwargs)
</p>

<p>
find_all_next(name, attrs, string, limit, **kwargs)
find_next(name, attrs, string, **kwargs)
find_all_previous(name, attrs, string, limit, **kwargs)
find_previous(name, attrs, string, **kwargs)
.contents and .children
</p>
</div>
</div>
</div>



<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> select方法</h2>
<div class="outline-text-2" id="text-6">
<p>
select方法通过CSS选择器来进行标签元素的选择。原则上上面谈论的那些方法已经能够满足我们大部分的需求了，再加上专门针对某个个别网站的个别网页的css布局而进行抓取，这种抓取方法是很不灵活很有局限性的，所以select方法应该作为用户的最后备选方案。
</p>
</div>
</div>


<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 解析部分文档来提升效率</h2>
<div class="outline-text-2" id="text-7">
<p>
请看到下面这个函数，其用途是将整个webpage的所有a连接有href属性的链接收集起来。
</p>

<div class="highlight"><pre><span class="k">def</span> <span class="nf">get_webpage_links</span><span class="p">(</span><span class="n">html</span><span class="p">,</span><span class="n">baseurl</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; 刷本网页 a标签 有 href 属性的所有 links</span>
<span class="sd">    绝对化路径 去除fragment 返回字典值去重</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html</span><span class="p">,</span> <span class="s">&#39;lxml&#39;</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">SoupStrainer</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">))</span>
    <span class="n">links</span> <span class="o">=</span> <span class="p">[</span><span class="n">link</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;href&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="n">href</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>
    <span class="n">links</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_absolute_url</span><span class="p">(</span><span class="n">baseurl</span><span class="p">,</span><span class="n">link</span><span class="p">)</span> <span class="k">for</span>  <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">]</span>
    <span class="n">links</span> <span class="o">=</span> <span class="p">[</span><span class="n">remove_url_fragment</span><span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
</pre></div>

<p>
其中:
</p>
<pre class="example">
soup = BeautifulSoup(html, 'lxml', parse_only=SoupStrainer('a'))
</pre>
<p>
<code>parse_only</code> 参数用于控制BeautifulSoup一开始刷文档时创建标签元素对象的时候，就只刷某些标签而进行了过滤操作，从而大大节省了工作量。具体参数是创建一个 <code>SoupStrainer</code> 对象，其接受的过滤器语法和前面叙述的一样。
</p>
</div>
</div>
</div>
<footer class="footer">
<div class="container">
<p class="text-muted">作者: 万泽(德山书生); 编者: 万泽(德山书生); 最后修改时间: 2015-11-15 21:23.</p></div>
</body>
</html>
